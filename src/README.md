
---

# 共享单车项目设计

## 项目简介

该项目旨在设计并实现一个高效的共享单车管理系统，借助多种开源工具与框架来提高系统的可维护性、性能以及开发效率。
支持用户注册登录，扫码骑行单车，管理员增加删除单车，单车的维护管理等服务

## 项目特点

- **自动化配置管理**：使用开源的 [iniparser](https://github.com/ndevilla/iniparser) 框架，方便快捷地管理系统配置。
- **强大的日志管理**：基于 [log4cpp](http://log4cpp.sourceforge.net/) 实现日志自动记录，提升调试与问题追踪的效率。
- **高性能协议通信**：结合 Google 开发的 Protobuf 进行数据序列化与通信，提供高效的二进制传输解决方案。
- **任务分发与并发支持**：通过 libevent 框架实现网络消息的收发及事件处理，结合线程池设计以提高并发处理能力。

## 系统架构

### 配置管理

利用 **iniparser** 处理系统配置文件，提供以下特性：

- 易于解析和更新配置。
- 轻量化且可扩展。

下载iniparser包，使用cmake，make进行编译，将iniparser下的src目录下的两个头文件拷贝到项目的第三方库目录中进行管理，以及对应产生的静态库文件

管理系统的数据库配置，以及端口号，过期时间等
编写系统的基础配置文件，然后通过iniparser读取配置信息


### 日志系统

系统日志采用 **log4cpp** 框架，具备以下功能：

- 自动记录运行时操作信息。
- 支持多种日志输出格式和级别，便于问题定位。

下载log4cpp压缩包，进行解压后，对它进行编译，安装，将产生的log4cpp目录文件整体拷贝到对应的项目下辖管理的第三方库目录中，产生的库文件一并管理
编写log.conf文件
### 数据通信

使用 **Protobuf** 实现客户端与服务器之间的数据协议：

- 提供快速且可靠的消息序列化机制。
- 支持多语言数据交换，便于扩展与集成。

服务端客户端采取统一的请求响应协议，下载protobuf程序并编译后。设计好交互协议，将协议写为proto文件,使用以下命令编译产生协议的头文件和源文件
将google目录文件导入库管理，将产生的protobuf静态库文件导入项目下管理

```bash

protoc -I=$SRC_DIR --cpp_out=$DST_DIR  xxx.proto\

```

这里采取的协议格式为
tag+eventID+dataLength+data

### 网络框架

libevent是一个轻量级的开源的高性能的事件触发的网络库，适用于windows、linux、bsd等多种平台，内部使用select、epoll、kqueue等系统调用管理事件机制。
libevent提供了从建立socket连接到销毁的全生命周期流程的管理，可以使用它提供的封装良好的接口进行封闭

采用 **libevent** 作为网络传输层，负责处理以下任务：
管理网络会话，绑定对应的网络端口
监听网络端口事件，监听事件后，读取事件的消息数据，将事件传递给事件管理器进行事件的分发处理
设置监听链接端口读写超时设置

应用于NetworkInterface类中，负责套接字的管理，端口的监听，以及事件的转发，将事件转发给事件处理类，由事件处理类DispatchMsgService进行事件消息的分发

### 事件的定义与分类

iEvent提供抽象事件的统一特征，作为基类，提供事件id和序号以及事件的连接上下文信息的管理
eventType中提供了相关事件类型的定义，单车状态的定义，以及错误状态码
eventDef中提供了所有事件类型对应的事件类，事件将以事件类的形态在服务端中传递
iEventHandler提供事件处理的抽象类，将由具体的事件处理类继承从而提供事件的处理服务


### 消息事件的订阅与分发

设计多个事件的ID类型，事件的序列编号，以及每个事件对应的类
事件消息分发处理类设计为单例模式，由事件处理器初始的时候进行用户事件的注册，并由事件处理器进行用户事件的注销
响应事件队列处理，线程池同步

事件处理类DispatchMsgService提供消息事件的分析、分类，之后分配对应的处理函数，然后设置回调函数，接着加入任务队列中，由线程池进行事件队列中事件队列的处理

事件处理分发类结合了线程池技术，只需将分发好的事件加入任务队列中，线程池便可以自行处理对应的消息事件
线程池的创建和销毁由事件处理类进行统一管理

提供事件消息的订阅服务以及取消订阅服务，在系统用户业务启动的时候可以调用订阅服务进行事件服务的订阅
提供线程池统一的回调函数svc，svc可以根据事件进行对应事件的返回

提供事件的分析处理，根据事件ID，读取消息的数据信息，生成对应的封装好的请求事件，提供传递
事件派发处理，根据请求事件id，获取对应的处理函数，处理函数再返回对应的响应事件

提供处理全部事件的消息响应处理，并发回给networkInterface

### 多线程并发处理事务

由事件分发处理器进行事件的分发，根据事件生成任务并加入任务队列转发给线程池，线程获取事件后进行对应事件的处理，调用事件的回调函数

#### 线程设计

thread.h定义线程的锁函数以及条件变量函数
以及指定线程部分以C编译
thread_pool.h定义了线程任务，线程任务队列，以及线程池
thread_cond和thread_mutex定义了thread的条件变量设计操作以及线程的锁操作
线程池通过维护任务队列和线程池，当有新任务的时候就上锁加入任务队列，并发出信号通知工作线程，当线程取出任务的时候就上锁取出任务然后释放锁并执行

主要被用在了用户事务的获取验证码以及校验的过程中

### 客户端用户事件处理

继承iEventHandler提供事件的处理，并返回对应的事件
初始化时向事件处理类注册事件以及处理器
生成验证码的时候，给用户名和验证码映射器上锁，并设置用户的验证码
处理用户注册请求的时候，在获取验证码进行对比验证的时候需要上锁
任何用户事件类都夹带数据项，将操作的结果数据加入事件类的数据项之中就可以返回了

### 用户业务实现

用于校验用户信息，管理员管理单车，执行查询，增加删除操作

### MYsql

安装MYSQL库和MYSQL服务器

```bash
sudo apt-get install libmysqlclient-dev

```

编译链接： -lmysqlclient 

安装mysql 服务器

``` bash

sudo apt-get install mysql-server

```
设计结果类存放MYSQL操作结果

使用MYSQL提供的开发库，维护MYSQL的连接句柄，使用共享指针的方式创建数据库的连接并获取数据


### 处理流程

#### 网络部分

主程序启动网络服务类，并开启监听，之后循环调用网络服务类的事件分发处理函数进行事件消息的响应处理
网络服务类在启动的时候使用libevent创建事件池，并使用libevent提供的方法创建socket并绑定端口，设置监听端口的回调函数并进入监听状态

端口的控制监听的回调函数为每一个新连接创建一个缓冲事件管理，并保存该连接对象的状态，并将这个客户端连接加入事件处理类的客户端用户列表，并配备对应的回调函数，设置连接的超时时间，超过时间也有对应的回调函数
当获取客户端请求的时候，网路服务处理类调用请求处理函数，该函数读取前端请求的头部标识，如果不是需要的标识则丢弃；当标识验证通过则读取事件的ID类型和数据长度，当校验事件ID和数据长度通过后则设置该事件的连接状态为读取数据状态，下一步转入读取数据流程

#### 事件处理部分

此时连接维护一个读取数据长度以及消息数据长度的长度，当读取完全部数据的时候就调用事件处理类的parseEvent函数分析事件类型，获得完整封装的请求事件类，之后事务处理类将该事件投入线程池管理；
如果数据并没有一次读取完，那么事件对应的连接状态不会改变，还是保持读取消息数据体的状态，直到下一次有新的数据到来，触发libevent的回调函数继续读取

当将事件入队的时候，创建一个任务，配置它的处理函数为事件处理类的统一回调函数svc，以及设置任务的上下文，然后立刻投入线程池的任务队列中，线程条件变量就会通知工作线程来处理任务

当线程获取该任务的时候就会调用执行svc函数，svc就会处理process该请求事件，然后调用用户事件处理类生成响应事件，并上锁，将响应事件加入响应事件队列

#### 网络发送响应信息

之后网络服务类的事件分发处理函数就会调用事件处理类的响应函数，从响应事件队列中取得响应事件，这个过程是需要上锁的，然后就根据响应事件的id类型，并获得事件的消息体，然后完成响应数据的组装，接着由网络服务类将响应消息发送给客户端


![alt text](image.png)
![alt text](image-1.png)